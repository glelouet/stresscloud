package fr.lelouet.stress;

/*
 * #%L
 * stresscloud
 * %%
 * Copyright (C) 2012 - 2015 Mines de Nantes
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as 
 * published by the Free Software Foundation, either version 3 of the 
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public 
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

/**
 * the result of benching with {@link StressBencher}<br />
 * contains properties about the stress execution, and list of stress
 * evaluations.<br />
 * also contains
 * 
 * @author Guillaume Le LouÃ«t < guillaume.le-louet@mines-nantes.fr >
 */
public class StressBenchResult extends Properties {

	private static final long serialVersionUID = 1L;

	private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory
			.getLogger(StressBenchResult.class);

	public static class BenchEntry {
		// time load %skipped %cpuload userData
		public long date;
		public double load;
		public double errorRate;
		public double cpupct;
		public String userData;

		/** writes this as a plain string, to parse it later. */
		public String toPlain() {
			return date + " " + load + " " + errorRate + " " + cpupct
					+ (userData == null ? "" : " " + userData);
		}

		/** all data set to null */
		public BenchEntry() {
		}

		/**
		 * parses the entry, can throw an exception.
		 * 
		 * @param from
		 *            the string generated by {@link #toPlain()}
		 */
		public BenchEntry(String from) {
			// System.err.println("entry splitted from " + from);
			String[] splitted = from.split(" ", 5);
			date = Long.parseLong(splitted[0]);
			load = Double.parseDouble(splitted[1]);
			errorRate = Double.parseDouble(splitted[2]);
			cpupct = Double.parseDouble(splitted[3]);
			if (splitted.length > 4) {
				userData = splitted[4];
			}
			// System.err.println(from+" -> "+toPlain());
		}

		public static BenchEntry parse(String entry) {
			try {
				BenchEntry ret = new BenchEntry(entry);
				return ret;
			} catch (Exception e) {
				logger.warn("while parsing " + entry, e);
				return null;
			}
		}
	}

	public HashMap<String, BufferedWriter> exports = new HashMap<String, BufferedWriter>();

	public static final String dataDesc = "time load %skipped %cpuload userData";

	/**
	 * starts exporting new benches to a file.
	 * 
	 * @param fileName
	 * @return
	 */
	public boolean export(String fileName) {
		if (!exports.containsKey(fileName)) {
			try {
				BufferedWriter writer = new BufferedWriter(new FileWriter(
						fileName));
				exports.put(fileName, writer);
				writer.write(plainDesc() + "\n");
				writer.write(dataDesc + "\n");
				return true;
			} catch (IOException e) {
				logger.warn("while opening file to write " + fileName, e);
			}
		}
		return false;
	}

	public boolean close(String fileName) {
		BufferedWriter bw = exports.remove(fileName);
		if (bw != null) {
			try {
				bw.close();
			} catch (IOException e) {
				logger.warn("", e);
			}
		}
		return bw != null;
	}

	public List<BenchEntry> entries = new ArrayList<StressBenchResult.BenchEntry>();

	public void add(BenchEntry e) {
		entries.add(e);
		String plain = e.toPlain() + "\n";
		for (BufferedWriter bw : exports.values()) {
			try {
				bw.write(plain);
			} catch (IOException e1) {
				logger.warn("while writing " + plain, e);
			}
		}
	}

	public String plainDesc() {
		String ret = null;
		for (java.util.Map.Entry<Object, Object> e : entrySet()) {
			ret = ret == null ? "" : ret + " ";
			ret += ("" + e.getKey()).replaceAll(" ", "_").replaceAll("=", "-")
					+ "=" + ("" + e.getValue()).replaceAll(" ", "_");
		}
		return ret;
	}

	public void closeAll() {
		for (BufferedWriter e : exports.values()) {
			try {
				e.close();
			} catch (IOException e1) {
				logger.warn("", e);
			}
		}
	}

	/**
	 * load data stored using the {@link #export(String)} and
	 * {@link #add(BenchEntry)} methods
	 */
	public StressBenchResult load(String fileName) {
		try {
			BufferedReader r = new BufferedReader(new FileReader(fileName));
			for (String s : r.readLine().split(" ")) {
				// System.err.println("setting property with " + s);
				String[] keyval = s.split("=", 2);
				setProperty(keyval[0], keyval[1]);
			}
			r.readLine();
			String line = null;
			do {
				line = r.readLine();
				if (line != null) {
					add(new BenchEntry(line));
				}
			} while (line != null);
			r.close();
		} catch (Exception e) {
			logger.warn("while loading file " + fileName, e);
		}
		return this;
	}

	// public void graph(String fileName) {
	// JavaPlot p = new JavaPlot();
	// PointDataSet<Double> cpupct = new PointDataSet<Double>();
	// PointDataSet<Double> errors = new PointDataSet<Double>();
	// for (BenchEntry be : entries) {
	// cpupct.addPoint(be.load, be.cpupct);
	// errors.addPoint(be.load, be.errorRate);
	// }
	// ImageTerminal term = new ImageTerminal();
	// p.setTerminal(term);
	// PlotStyle style = new PlotStyle();
	// style.setStyle(Style.LINESPOINTS);
	// DataSetPlot cpupctplots = new DataSetPlot(cpupct);
	// cpupctplots.setTitle("cpu percentage");
	// cpupctplots.setPlotStyle(style);
	// DataSetPlot errorsplots = new DataSetPlot(errors);
	// errorsplots.setTitle("error rate percentage");
	// errorsplots.setPlotStyle(style);
	// p.addPlot(cpupctplots);
	// p.addPlot(errorsplots);
	// p.plot();
	// try {
	// ImageIO.write(term.getImage(), "png", new File(fileName));
	// } catch (IOException ex) {
	// System.err.print(ex);
	// }
	// }

}
